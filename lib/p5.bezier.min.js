!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.p5bezier=e():t.p5bezier=e()}(self,(function(){return(()=>{"use strict";var t={d:(e,i)=>{for(var r in i)t.o(i,r)&&!t.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:i[r]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r:t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})}},e={};t.r(e),t.d(e,{initBezier:()=>h,newBezier:()=>l,newBezierObj:()=>a});const i=[.2,.1,.05,.04,.02,.01,.008,.002,.001,5e-4,1e-4];let r,s,o,n;function h(t,e=!1){r=t,s=r.drawingContext,o=t.isP3D?3:2,n=e}function l(t,e="OPEN",r=7){if(n&&!Array.isArray(t))throw typeof t;const h=i[r];if(0===o);else{if(n)for(let e of t)if(!Array.isArray(t)||e.length!==o)throw"One or more points in the array are not input correctly.";"CLOSE"===e&&t.push(t[0]);let i=t.length-1;if(s.beginPath(),s.moveTo(...t[0]),2===o){let e,r,o,n;for(o=0;o<=1;o+=h){for(e=0,r=0,n=0;n<=i;n++)e+=f(i)/(f(n)*f(i-n))*Math.pow(1-o,i-n)*Math.pow(o,n)*t[n][0],r+=f(i)/(f(n)*f(i-n))*Math.pow(1-o,i-n)*Math.pow(o,n)*t[n][1];s.lineTo(e,r)}s.lineTo(...t.slice(-1)[0])}else if(3===o){let e,r,o,n=[0,0,0];for(e=0;e<=1;e+=h){for(n=[0,0,0],r=0;r<=i;r++)for(o=0;o<3;o++)n[o]+=f(i)/(f(r)*f(i-r))*Math.pow(1-e,i-r)*Math.pow(e,r)*t[r][o];s.lineTo(...n)}s.lineTo(...t.slice(-1)[0])}if("CLOSE"===e)s.closePath();else if(n&&"OPEN"!==e)throw"Close Type Error. A bezier curve can only be either OPEN or CLOSE.";p()}}function a(t,e="OPEN",r=7){const s=i[r];if(n&&!Array.isArray(t))throw typeof t;if(n)for(let e of t)if(!Array.isArray(t)||e.length!==o)throw"One or more points in the array are not input correctly.";return new d(t,e,s,o)}function f(t){return t>1?t*f(t-1):1}function c(){return 4===arguments.length?Math.hypot(arguments[0]-arguments[2],arguments[1]-arguments[3]):6===arguments.length?Math.hypot(arguments[0]-arguments[3],arguments[1]-arguments[4],arguments[2]-arguments[5]):0}function p(){r._doFill&&s.fill(),r._doStroke&&s.stroke()}class d{constructor(t,e,i,r,s=null){if(n&&2!==r&&3!==r)throw r;if(this.controlPoints=t,"CLOSE"===e)this.controlPoints.push(t[0]),this.closeType="CLOSE";else{if("OPEN"!==e)throw"Close Type Error. A bezier curve can only be either OPEN or CLOSE.";this.closeType="OPEN"}this.dimension=r,this.increment=i,this.vertexList=[],this.vertexListLen=0,this.p=this.controlPoints.length,this.n=this.p-1,null===s?this._buildVertexList():(this.vertexList=s,this.vertexListLen=this.vertexList.length)}_buildVertexList(){if(this.vertexList=[],2===this.dimension){let t,e,i,r;for(i=0;i<=1;i+=this.increment){for(t=0,e=0,r=0;r<=this.n;r++)t+=f(this.n)/(f(r)*f(this.n-r))*Math.pow(1-i,this.n-r)*Math.pow(i,r)*this.controlPoints[r][0],e+=f(this.n)/(f(r)*f(this.n-r))*Math.pow(1-i,this.n-r)*Math.pow(i,r)*this.controlPoints[r][1];this.vertexList.push([t,e])}}else if(3===this.dimension){let t,e,i,r=[0,0,0];for(t=0;t<=1;t+=this.increment){for(r[0]=0,r[1]=0,r[2]=0,e=0;e<=this.n;e++)for(i=0;i<3;i++)r[i]+=f(this.n)/(f(e)*f(this.n-e))*Math.pow(1-t,this.n-e)*Math.pow(t,e)*this.controlPoints[e][i];this.vertexList.push(r)}}return this._addVertex(this.controlPoints.slice(-1)[0]),this.dimension=this.vertexList[0].length,this.vertexListLen=this.vertexList.length,this.vertexList}_addVertex(t){if(2!==this.dimension&&3!==this.dimension)throw"Vertices can only be in 2D or 3D space.";s.lineTo(...t)}_distVertex(t,e){return 2===this.dimension?c(t[0],t[1],e[0],e[1]):3===this.dimension?c(t[0],t[1],t[2],e[0],e[1],e[2]):void 0}draw(t){if(t){if(!(Array.isArray(t)&&2===t.length&&this.increment<=.008))throw this.increment>.008?"Fidelity is too low for a dash line. It should be at least 6.":"Your dash array input is not valid. Make sure it's an array of two numbers.";{let e=Math.abs(t[0]),i=e+Math.abs(t[1]),r=0,o=0,n=this.vertexList[0],h=!0;s.save(),s.fillStyle="rgba(0, 0, 0, 0)",s.beginPath(),s.moveTo(...this.vertexList[0]);for(let t=1;t<this.vertexListLen;t++)r+=this._distVertex(n,this.vertexList[t]),o=r%i,o<=e&&h?this._addVertex(this.vertexList[t]):o>e&&o<=i&&h?h=!1:o<=e&&!h&&(s.moveTo(...this.vertexList[t]),h=!0),n=this.vertexList[t];p(),s.restore()}}else{s.beginPath();for(let t of this.vertexList)this._addVertex(t);"CLOSE"===this.closeType&&s.closePath(),p()}}update(t){if(t.length!==this.controlPoints.length)throw"The number of points changed. (Keep the point array length the same.)";u(this.controlPoints,t)||(this.controlPoints=t,this._buildVertexList())}move(t,e,i=null,r=!0,s=0){if(null===i&&3===this.dimension)throw"To move a 3D curve, please specify (x, y, z).";{let o=[t,e];null!==i&&o.push(i);let n=[];for(let t=0;t<this.vertexListLen;t++)n.push(this.vertexList[t].slice());let h=new d(this.controlPoints,this.closeType,this.increment,this.dimension,n);for(let t=0;t<h.vertexListLen;t++)for(let e=0;e<h.dimension;e++)h.vertexList[t][e]+=o[e];return r&&h.draw(s),h}}shortest(t,e,i=0){let r,s=-1,o=0;for(let n of this.vertexList)-1===s?(s=this._distVertex(n,[t,e,i]),r=n):(o=this._distVertex(n,[t,e,i]),s>o&&(s=o,r=n));return r}}const u=(t,e)=>t.length===e.length&&t.every(((t,i)=>t===e[i]));return e})()}));