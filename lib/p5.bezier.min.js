!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.p5bezier=e():t.p5bezier=e()}(self,(function(){return(()=>{"use strict";var t={693:(t,e,i)=>{i.r(e),i.d(e,{initBezier:()=>l,newBezier:()=>a,newBezierObj:()=>f});const r=[.2,.1,.05,.04,.02,.01,.008,.002,.001,5e-4,1e-4];let o,s,n,h;function l(t,e=!1){o=t,s=o.drawingContext,n=t.isP3D?3:2,h=e}function a(t,e="OPEN",i=7){if(h&&!Array.isArray(t))throw typeof t;const o=r[i];if(0===n);else{if(h)for(let e of t)if(!Array.isArray(t)||e.length!==n)throw"One or more points in the array are not input correctly.";"CLOSE"===e&&t.push(t[0]);let i=t.length-1;if(s.beginPath(),s.moveTo(...t[0]),2===n){let e,r,n,h;for(n=0;n<=1;n+=o){for(e=0,r=0,h=0;h<=i;h++)e+=c(i)/(c(h)*c(i-h))*Math.pow(1-n,i-h)*Math.pow(n,h)*t[h][0],r+=c(i)/(c(h)*c(i-h))*Math.pow(1-n,i-h)*Math.pow(n,h)*t[h][1];s.lineTo(e,r)}s.lineTo(...t.slice(-1)[0])}else if(3===n){let e,r,n,h=[0,0,0];for(e=0;e<=1;e+=o){for(h=[0,0,0],r=0;r<=i;r++)for(n=0;n<3;n++)h[n]+=c(i)/(c(r)*c(i-r))*Math.pow(1-e,i-r)*Math.pow(e,r)*t[r][n];s.lineTo(...h)}s.lineTo(...t.slice(-1)[0])}if("CLOSE"===e)s.closePath();else if(h&&"OPEN"!==e)throw"Close Type Error. A bezier curve can only be either OPEN or CLOSE.";u()}}function f(t,e="OPEN",i=7){const o=r[i];if(h&&!Array.isArray(t))throw typeof t;if(h)for(let e of t)if(!Array.isArray(t)||e.length!==n)throw"One or more points in the array are not input correctly.";return new d(t,e,o,n)}function c(t){return t>1?t*c(t-1):1}function p(){return 4===arguments.length?Math.hypot(arguments[0]-arguments[2],arguments[1]-arguments[3]):6===arguments.length?Math.hypot(arguments[0]-arguments[3],arguments[1]-arguments[4],arguments[2]-arguments[5]):0}function u(){o._doFill&&s.fill(),o._doStroke&&s.stroke()}class d{constructor(t,e,i,r,o=null){if(h&&2!==r&&3!==r)throw r;if(this.controlPoints=t,"CLOSE"===e)this.controlPoints.push(t[0]),this.closeType="CLOSE";else{if("OPEN"!==e)throw"Close Type Error. A bezier curve can only be either OPEN or CLOSE.";this.closeType="OPEN"}this.dimension=r,this.increment=i,this.vertexList=[],this.vertexListLen=0,this.p=this.controlPoints.length,this.n=this.p-1,null===o?this._buildVertexList():(this.vertexList=o,this.vertexListLen=this.vertexList.length)}_buildVertexList(){if(this.vertexList=[],2===this.dimension){let t,e,i,r;for(i=0;i<=1;i+=this.increment){for(t=0,e=0,r=0;r<=this.n;r++)t+=c(this.n)/(c(r)*c(this.n-r))*Math.pow(1-i,this.n-r)*Math.pow(i,r)*this.controlPoints[r][0],e+=c(this.n)/(c(r)*c(this.n-r))*Math.pow(1-i,this.n-r)*Math.pow(i,r)*this.controlPoints[r][1];this.vertexList.push([t,e])}}else if(3===this.dimension){let t,e,i,r=[0,0,0];for(t=0;t<=1;t+=this.increment){for(r[0]=0,r[1]=0,r[2]=0,e=0;e<=this.n;e++)for(i=0;i<3;i++)r[i]+=c(this.n)/(c(e)*c(this.n-e))*Math.pow(1-t,this.n-e)*Math.pow(t,e)*this.controlPoints[e][i];this.vertexList.push(r)}}return this._addVertex(this.controlPoints.slice(-1)[0]),this.dimension=this.vertexList[0].length,this.vertexListLen=this.vertexList.length,this.vertexList}_addVertex(t){if(2!==this.dimension&&3!==this.dimension)throw"Vertices can only be in 2D or 3D space.";s.lineTo(...t)}_distVertex(t,e){return 2===this.dimension?p(t[0],t[1],e[0],e[1]):3===this.dimension?p(t[0],t[1],t[2],e[0],e[1],e[2]):void 0}draw(t){if(t){if(!(Array.isArray(t)&&2===t.length&&this.increment<=.008))throw this.increment>.008?"Fidelity is too low for a dash line. It should be at least 6.":"Your dash array input is not valid. Make sure it's an array of two numbers.";{let e=Math.abs(t[0]),i=e+Math.abs(t[1]),r=0,o=0,n=this.vertexList[0],h=!0;s.save(),s.fillStyle="rgba(0, 0, 0, 0)",s.beginPath(),s.moveTo(...this.vertexList[0]);for(let t=1;t<this.vertexListLen;t++)r+=this._distVertex(n,this.vertexList[t]),o=r%i,o<=e&&h?this._addVertex(this.vertexList[t]):o>e&&o<=i&&h?h=!1:o<=e&&!h&&(s.moveTo(...this.vertexList[t]),h=!0),n=this.vertexList[t];u(),s.restore()}}else{s.beginPath();for(let t of this.vertexList)this._addVertex(t);"CLOSE"===this.closeType&&s.closePath(),u()}}update(t){if(t.length!==this.controlPoints.length)throw"The number of points changed. (Keep the point array length the same.)";y(this.controlPoints,t)||(this.controlPoints=t,this._buildVertexList())}move(t,e,i=null,r=!0,o=0){if(null===i&&3===this.dimension)throw"To move a 3D curve, please specify (x, y, z).";{let s=[t,e];null!==i&&s.push(i);let n=[];for(let t=0;t<this.vertexListLen;t++)n.push(this.vertexList[t].slice());let h=new d(this.controlPoints,this.closeType,this.increment,this.dimension,n);for(let t=0;t<h.vertexListLen;t++)for(let e=0;e<h.dimension;e++)h.vertexList[t][e]+=s[e];return r&&h.draw(o),h}}shortest(t,e,i=0){let r,o=-1,s=0;for(let n of this.vertexList)-1===o?(o=this._distVertex(n,[t,e,i]),r=n):(s=this._distVertex(n,[t,e,i]),o>s&&(o=s,r=n));return r}}const y=(t,e)=>t.length===e.length&&t.every(((t,i)=>t===e[i]))}},e={};function i(r){if(e[r])return e[r].exports;var o=e[r]={exports:{}};return t[r](o,o.exports,i),o.exports}return i.d=(t,e)=>{for(var r in e)i.o(e,r)&&!i.o(t,r)&&Object.defineProperty(t,r,{enumerable:!0,get:e[r]})},i.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),i.r=t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},i(693)})()}));