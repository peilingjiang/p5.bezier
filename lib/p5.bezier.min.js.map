{"version":3,"file":"p5.bezier.min.js","mappings":"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","sources":["webpack://p5bezier/webpack/universalModuleDefinition","webpack://p5bezier/webpack/bootstrap","webpack://p5bezier/webpack/runtime/define property getters","webpack://p5bezier/webpack/runtime/hasOwnProperty shorthand","webpack://p5bezier/webpack/runtime/make namespace object","webpack://p5bezier/./src/p5.bezier.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"p5bezier\"] = factory();\n\telse\n\t\troot[\"p5bezier\"] = factory();\n})(self, function() {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/*\np5.bezier library by Peiling Jiang\n2020\n*/\n\nconst p5bezierAccuracyListAll = [\n  0.2,\n  0.1,\n  0.05,\n  0.04,\n  0.02,\n  0.01,\n  0.008,\n  0.002,\n  0.001,\n  0.0005,\n  0.0001,\n]\n\nlet _canvas, _ctx, _dimension, _strict\n\nexport function initBezier(canvas, strictMode = false) {\n  _canvas = canvas\n  _ctx = _canvas.drawingContext\n  _dimension = canvas.isP3D ? 3 : 2\n  _strict = strictMode // Always check and throw errors or not\n}\n\nexport function newBezier(pointList, closeType = 'OPEN', accuracy = 7) {\n  if (_strict && !Array.isArray(pointList))\n    throw ('newBezier() function expects an array, got %s.', typeof pointList)\n\n  // Define the increment of t based on accuracy\n  const tIncrement = p5bezierAccuracyListAll[accuracy]\n\n  if (_dimension !== 0) {\n    // Check if all points are valid\n    if (_strict)\n      for (let point of pointList)\n        if (!Array.isArray(pointList) || point.length !== _dimension)\n          throw 'One or more points in the array are not input correctly.'\n\n    // Add the first point as the last point to close the curve\n    if (closeType === 'CLOSE') pointList.push(pointList[0])\n    let p = pointList.length // pointList has p points for (p - 1) degree curves\n    let n = p - 1\n\n    _ctx.beginPath()\n    _ctx.moveTo(...pointList[0])\n    // Are we drawing 2D or 3D curves\n    if (_dimension === 2) {\n      // 2-Dimensional bezier curve\n      let x, y, t, i\n      for (t = 0; t <= 1; t += tIncrement) {\n        x = 0\n        y = 0\n        for (i = 0; i <= n; i++) {\n          // i point in pointList\n          x +=\n            (_helper_factorial(n) /\n              (_helper_factorial(i) * _helper_factorial(n - i))) *\n            Math.pow(1 - t, n - i) *\n            Math.pow(t, i) *\n            pointList[i][0]\n          y +=\n            (_helper_factorial(n) /\n              (_helper_factorial(i) * _helper_factorial(n - i))) *\n            Math.pow(1 - t, n - i) *\n            Math.pow(t, i) *\n            pointList[i][1]\n        }\n        _ctx.lineTo(x, y)\n      }\n      _ctx.lineTo(...pointList.slice(-1)[0])\n    } else if (_dimension === 3) {\n      // 3-Dimensional bezier curve\n      let xyz = [0, 0, 0],\n        t,\n        i,\n        d\n      for (t = 0; t <= 1; t += tIncrement) {\n        xyz = [0, 0, 0]\n        for (i = 0; i <= n; i++) {\n          for (d = 0; d < 3; d++) {\n            xyz[d] +=\n              (_helper_factorial(n) /\n                (_helper_factorial(i) * _helper_factorial(n - i))) *\n              Math.pow(1 - t, n - i) *\n              Math.pow(t, i) *\n              pointList[i][d]\n          }\n        }\n        _ctx.lineTo(...xyz)\n      }\n      _ctx.lineTo(...pointList.slice(-1)[0])\n    }\n\n    if (closeType === 'CLOSE') _ctx.closePath()\n    else if (_strict && closeType !== 'OPEN')\n      throw 'Close Type Error. A bezier curve can only be either OPEN or CLOSE.'\n\n    _helper_style()\n\n    return\n  }\n}\n\nexport function newBezierObj(pointList, closeType = 'OPEN', accuracy = 7) {\n  // Define the increment of t based on accuracy\n  const tIncrement = p5bezierAccuracyListAll[accuracy]\n\n  if (_strict && !Array.isArray(pointList))\n    throw ('newBezier() function expects an array, got %s.', typeof pointList)\n\n  // Check if all points are valid\n  if (_strict)\n    for (let point of pointList)\n      if (!Array.isArray(pointList) || point.length !== _dimension)\n        throw 'One or more points in the array are not input correctly.'\n\n  // All checks done\n  let bObj = new BezierCurve(pointList, closeType, tIncrement, _dimension)\n  return bObj\n}\n\nfunction _helper_factorial(a) {\n  // Factorial function for binomial coefficient calculation\n  return a > 1 ? a * _helper_factorial(a - 1) : 1\n}\n\nfunction _helper_dist() {\n  if (arguments.length === 4)\n    return Math.hypot(arguments[0] - arguments[2], arguments[1] - arguments[3])\n  else if (arguments.length === 6)\n    return Math.hypot(\n      arguments[0] - arguments[3],\n      arguments[1] - arguments[4],\n      arguments[2] - arguments[5]\n    )\n  return 0\n}\n\nfunction _helper_style() {\n  if (_canvas._doFill) _ctx.fill()\n  if (_canvas._doStroke) _ctx.stroke()\n}\n\nclass BezierCurve {\n  // Take pointList, closeType, tIncrement, bezierDimension into constructor\n  constructor(pL, closeT, tI, bD, vL = null) {\n    if (_strict && bD !== 2 && bD !== 3) {\n      throw (\n        (\"Dimension Error. The bezier curve is %d-dimensional and doesn't belong to our world.\",\n        bD)\n      )\n    }\n    this.controlPoints = pL\n\n    if (closeT === 'CLOSE') {\n      this.controlPoints.push(pL[0])\n      this.closeType = 'CLOSE'\n    } else if (closeT === 'OPEN') {\n      this.closeType = 'OPEN'\n    } else {\n      throw 'Close Type Error. A bezier curve can only be either OPEN or CLOSE.'\n    }\n\n    this.dimension = bD\n    this.increment = tI\n    this.vertexList = []\n    this.vertexListLen = 0\n    this.p = this.controlPoints.length // Has p points for (p - 1) degree curves\n    this.n = this.p - 1 // Degree\n    // Calculate thr vertex\n    if (vL === null) {\n      this._buildVertexList()\n    } else {\n      this.vertexList = vL\n      this.vertexListLen = this.vertexList.length\n    }\n  }\n\n  _buildVertexList() {\n    /*\n    Return vertexList\n    */\n    this.vertexList = []\n    if (this.dimension === 2) {\n      // 2-Dimensional bezier curve\n      let x, y, t, i\n      for (t = 0; t <= 1; t += this.increment) {\n        x = 0\n        y = 0\n        for (i = 0; i <= this.n; i++) {\n          // i point in pointList\n          x +=\n            (_helper_factorial(this.n) /\n              (_helper_factorial(i) * _helper_factorial(this.n - i))) *\n            Math.pow(1 - t, this.n - i) *\n            Math.pow(t, i) *\n            this.controlPoints[i][0]\n          y +=\n            (_helper_factorial(this.n) /\n              (_helper_factorial(i) * _helper_factorial(this.n - i))) *\n            Math.pow(1 - t, this.n - i) *\n            Math.pow(t, i) *\n            this.controlPoints[i][1]\n        }\n        this.vertexList.push([x, y])\n      }\n    } else if (this.dimension === 3) {\n      // 3-Dimensional bezier curve\n      let xyz = [0, 0, 0],\n        t,\n        i,\n        d\n      for (t = 0; t <= 1; t += this.increment) {\n        xyz[0] = 0\n        xyz[1] = 0\n        xyz[2] = 0\n        for (i = 0; i <= this.n; i++) {\n          for (d = 0; d < 3; d++) {\n            xyz[d] +=\n              (_helper_factorial(this.n) /\n                (_helper_factorial(i) * _helper_factorial(this.n - i))) *\n              Math.pow(1 - t, this.n - i) *\n              Math.pow(t, i) *\n              this.controlPoints[i][d]\n          }\n        }\n        this.vertexList.push(xyz)\n      }\n    }\n    // Ending fix\n    this._addVertex(this.controlPoints.slice(-1)[0])\n\n    this.dimension = this.vertexList[0].length // Update dimension\n    this.vertexListLen = this.vertexList.length // Update vertexListLen\n    return this.vertexList\n  }\n\n  _addVertex(vArray) {\n    // vArray is an array of [x, y] position or [x, y, z] position\n    if (this.dimension === 2 || this.dimension === 3) _ctx.lineTo(...vArray)\n    else throw 'Vertices can only be in 2D or 3D space.'\n  }\n\n  _distVertex(vArray1, vArray2) {\n    // Calculate the distance between\n    // vertex_array_1 and vertex_array_2\n    if (this.dimension === 2) {\n      return _helper_dist(vArray1[0], vArray1[1], vArray2[0], vArray2[1])\n    } else if (this.dimension === 3) {\n      return _helper_dist(\n        vArray1[0],\n        vArray1[1],\n        vArray1[2],\n        vArray2[0],\n        vArray2[1],\n        vArray2[2]\n      )\n    }\n  }\n\n  draw(dash) {\n    if (!dash) {\n      _ctx.beginPath()\n      for (let v of this.vertexList) {\n        this._addVertex(v)\n      }\n\n      if (this.closeType === 'CLOSE') _ctx.closePath()\n      _helper_style()\n    } else if (\n      Array.isArray(dash) &&\n      dash.length === 2 &&\n      this.increment <= 0.008\n    ) {\n      // Draw a dash curve\n      let solidPart = Math.abs(dash[0]) // Length of one solid part\n      let onePart = solidPart + Math.abs(dash[1]),\n        nowLen = 0,\n        modOnePart = 0\n      let lastVertex = this.vertexList[0]\n      let solid = true // true draw, false break\n\n      _ctx.save() // push\n      _ctx.fillStyle = 'rgba(0, 0, 0, 0)' // TODO: Enable fill\n      _ctx.beginPath()\n      _ctx.moveTo(...this.vertexList[0])\n      for (let v = 1; v < this.vertexListLen; v++) {\n        nowLen += this._distVertex(lastVertex, this.vertexList[v])\n        modOnePart = nowLen % onePart\n        if (modOnePart <= solidPart && solid) {\n          this._addVertex(this.vertexList[v])\n        } else if (modOnePart > solidPart && modOnePart <= onePart && solid) {\n          // endShape()\n          solid = false\n        } else if (modOnePart <= solidPart && !solid) {\n          _ctx.moveTo(...this.vertexList[v])\n          solid = true\n        }\n        lastVertex = this.vertexList[v]\n      }\n      // if (solid) {\n      //   // Shape didn't end\n      //   endShape()\n      // }\n      _helper_style()\n      _ctx.restore()\n    } else if (this.increment > 0.008) {\n      throw 'Fidelity is too low for a dash line. It should be at least 6.'\n    } else {\n      throw \"Your dash array input is not valid. Make sure it's an array of two numbers.\"\n    }\n  }\n\n  update(newControlList) {\n    /*\n    Update the vertexList when control points change\n    */\n    if (newControlList.length !== this.controlPoints.length) {\n      throw 'The number of points changed. (Keep the point array length the same.)'\n    } else if (equalArrays(this.controlPoints, newControlList)) {\n      // Do we really need to update? No.\n      // return ;\n    } else {\n      this.controlPoints = newControlList\n      this._buildVertexList()\n    }\n  }\n\n  move(x, y, z = null, toDraw = true, dash = 0) {\n    /*\n    Move the curve to another place\n    Return a new object\n    */\n    if (z === null && this.dimension === 3) {\n      // A 3D curve treated as 2D error\n      throw 'To move a 3D curve, please specify (x, y, z).'\n    } else {\n      let toMove = [x, y]\n      if (z !== null) toMove.push(z)\n      // Copy to a new object\n      let newCurveV = []\n      for (let i = 0; i < this.vertexListLen; i++)\n        newCurveV.push(this.vertexList[i].slice())\n      let newCurveObj = new BezierCurve(\n        this.controlPoints,\n        this.closeType,\n        this.increment,\n        this.dimension,\n        newCurveV\n      )\n      // Move\n      for (let i = 0; i < newCurveObj.vertexListLen; i++) {\n        for (let j = 0; j < newCurveObj.dimension; j++) {\n          newCurveObj.vertexList[i][j] += toMove[j]\n        }\n      }\n      if (toDraw) {\n        newCurveObj.draw(dash)\n      }\n      return newCurveObj\n    }\n  }\n\n  shortest(pX, pY, pZ = 0) {\n    // Return the point on curve that is closest to the point outside\n    // Always return array length of 3\n    // Last position (z) be 0 for all 2D calculation\n    let dMin = -1,\n      nowMin = 0\n    let minVertex\n    for (let v of this.vertexList) {\n      if (dMin === -1) {\n        dMin = this._distVertex(v, [pX, pY, pZ])\n        minVertex = v\n      } else {\n        nowMin = this._distVertex(v, [pX, pY, pZ])\n        if (dMin > nowMin) {\n          dMin = nowMin\n          minVertex = v\n        }\n      }\n    }\n    return minVertex // An array of vertex position\n  }\n}\n\n/* --------------------------------- HELPERS -------------------------------- */\n\n// https://www.30secondsofcode.org/blog/s/javascript-array-comparison\nconst equalArrays = (a, b) =>\n  a.length === b.length && a.every((v, i) => v === b[i])\n"],"names":["root","factory","exports","module","define","amd","self","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","p5bezierAccuracyListAll","_canvas","_ctx","_dimension","_strict","initBezier","canvas","strictMode","drawingContext","isP3D","newBezier","pointList","closeType","accuracy","Array","isArray","tIncrement","point","length","push","n","beginPath","moveTo","x","y","t","i","_helper_factorial","Math","pow","lineTo","slice","d","xyz","closePath","_helper_style","newBezierObj","BezierCurve","a","_helper_dist","arguments","hypot","_doFill","fill","_doStroke","stroke","constructor","pL","closeT","tI","bD","vL","this","controlPoints","dimension","increment","vertexList","vertexListLen","p","_buildVertexList","_addVertex","vArray","_distVertex","vArray1","vArray2","draw","dash","solidPart","abs","onePart","nowLen","modOnePart","lastVertex","solid","save","fillStyle","v","restore","update","newControlList","equalArrays","move","z","toDraw","toMove","newCurveV","newCurveObj","j","shortest","pX","pY","pZ","minVertex","dMin","nowMin","b","every"],"sourceRoot":""}