{"version":3,"file":"p5.bezier.min.js","mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;;UCVA;UACA;;;;;WCDA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEO;AACP;AACA;AACA,gEAAgE,iBAAiB;AACjF;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,QAAQ;AAC1B;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,kBAAkB,QAAQ;AAC1B;AACA,oBAAoB,QAAQ;AAC5B,sBAAsB,OAAO;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEO;AACP;AACA;;AAEA;AACA;AACA,mEAAmE,iBAAiB;AACpF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gDAAgD,GAAG;AACnD;;AAEA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,QAAQ;AAC1B;AACA;AACA,oBAAoB,aAAa;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,kBAAkB,QAAQ;AAC1B;AACA;AACA;AACA,oBAAoB,aAAa;AACjC,sBAAsB,OAAO;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,wBAAwB;AAC9C;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,sBAAsB,wBAAwB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,+BAA+B;AACrD,wBAAwB,2BAA2B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA","sources":["webpack://p5bezier/webpack/universalModuleDefinition","webpack://p5bezier/webpack/bootstrap","webpack://p5bezier/webpack/runtime/define property getters","webpack://p5bezier/webpack/runtime/hasOwnProperty shorthand","webpack://p5bezier/webpack/runtime/make namespace object","webpack://p5bezier/./src/p5.bezier.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"p5bezier\"] = factory();\n\telse\n\t\troot[\"p5bezier\"] = factory();\n})(self, function() {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/*\np5.bezier library by Peiling Jiang\n2020\n*/\n\nconst p5bezierAccuracyListAll = [\n  0.2, 0.1, 0.05, 0.04, 0.02, 0.01, 0.008, 0.002, 0.001, 0.0005, 0.0001,\n]\n\nlet _canvas,\n  _ctx,\n  _dimension,\n  _strict,\n  _useP5,\n  _beginPath,\n  _moveTo,\n  _lineTo,\n  _closePath\n\nexport function initBezier(canvas, strictMode = false) {\n  _canvas = canvas\n  _ctx = _canvas.drawingContext\n\n  // eslint-disable-next-line no-undef\n  if (p5 && canvas instanceof p5.Graphics) {\n    // p5 graphics\n    _useP5 = true\n    _dimension = _ctx.constructor.name === 'WebGLRenderingContext' ? 3 : 2\n\n    _beginPath = _canvas.beginShape\n    _moveTo = _canvas.vertex\n    _lineTo = _canvas.vertex\n    _closePath = _canvas.endShape\n    // eslint-disable-next-line no-undef\n  } else if ((p5 && canvas instanceof p5.Renderer) || canvas.drawingContext) {\n    // p5 canvas or other canvas\n    // eslint-disable-next-line no-undef\n    if (!p5 || (p5 && !(canvas instanceof p5.Renderer))) {\n      window.console.warn(\n        '[p5.bezier] Support for non-p5 canvas is not tested.'\n      )\n      _dimension = canvas.isP3D ? 3 : 2\n    } else {\n      _dimension = _ctx.constructor.name === 'WebGLRenderingContext' ? 3 : 2\n    }\n    _useP5 = false\n    _dimension = _ctx.constructor.name === 'WebGLRenderingContext' ? 3 : 2\n\n    _beginPath = _ctx.beginPath.bind(_ctx)\n    _moveTo = _ctx.moveTo.bind(_ctx)\n    _lineTo = _ctx.lineTo.bind(_ctx)\n    _closePath = _ctx.closePath.bind(_ctx)\n  } else {\n    throw new Error('[p5.bezier] Canvas is not supported.')\n  }\n\n  _strict = strictMode // Always check and throw errors or not\n}\n\nexport function newBezier(pointList, closeType = 'OPEN', accuracy = 7) {\n  if (_strict && !Array.isArray(pointList))\n    throw new Error(\n      `[p5.bezier] newBezier() function expects an array, got ${typeof pointList}.`\n    )\n\n  // Define the increment of t based on accuracy\n  const tIncrement = p5bezierAccuracyListAll[accuracy]\n\n  if (_dimension !== 0) {\n    // Check if all points are valid\n    if (_strict)\n      for (let point of pointList)\n        if (!Array.isArray(pointList) || point.length !== _dimension)\n          throw new Error(\n            '[p5.bezier] One or more points in the array are not input correctly.'\n          )\n\n    // Add the first point as the last point to close the curve\n    if (closeType === 'CLOSE') pointList.push(pointList[0])\n    let p = pointList.length // pointList has p points for (p - 1) degree curves\n    let n = p - 1\n\n    _beginPath()\n    _moveTo(...pointList[0])\n    // Are we drawing 2D or 3D curves\n    if (_dimension === 2) {\n      // 2-Dimensional bezier curve\n      let x, y, t, i\n      for (t = 0; t <= 1; t += tIncrement) {\n        x = 0\n        y = 0\n        for (i = 0; i <= n; i++) {\n          // i point in pointList\n          x +=\n            (_helper_factorial(n) /\n              (_helper_factorial(i) * _helper_factorial(n - i))) *\n            Math.pow(1 - t, n - i) *\n            Math.pow(t, i) *\n            pointList[i][0]\n          y +=\n            (_helper_factorial(n) /\n              (_helper_factorial(i) * _helper_factorial(n - i))) *\n            Math.pow(1 - t, n - i) *\n            Math.pow(t, i) *\n            pointList[i][1]\n        }\n        _lineTo(x, y)\n      }\n      _lineTo(...pointList.slice(-1)[0])\n    } else if (_dimension === 3) {\n      // 3-Dimensional bezier curve\n      let xyz = [0, 0, 0],\n        t,\n        i,\n        d\n      for (t = 0; t <= 1; t += tIncrement) {\n        xyz = [0, 0, 0]\n        for (i = 0; i <= n; i++) {\n          for (d = 0; d < 3; d++) {\n            xyz[d] +=\n              (_helper_factorial(n) /\n                (_helper_factorial(i) * _helper_factorial(n - i))) *\n              Math.pow(1 - t, n - i) *\n              Math.pow(t, i) *\n              pointList[i][d]\n          }\n        }\n        _lineTo(...xyz)\n      }\n      _lineTo(...pointList.slice(-1)[0])\n    }\n\n    if (_useP5) _closePath(closeType)\n    else if (closeType === 'CLOSE') _closePath()\n    else if (_strict && closeType !== 'OPEN')\n      throw new Error(\n        '[p5.bezier] Close type error. A bezier curve can only be either OPEN or CLOSE.'\n      )\n\n    _helper_style()\n\n    return\n  }\n}\n\nexport function newBezierObj(pointList, closeType = 'OPEN', accuracy = 7) {\n  // Define the increment of t based on accuracy\n  const tIncrement = p5bezierAccuracyListAll[accuracy]\n\n  if (_strict && !Array.isArray(pointList))\n    throw new Error(\n      `[p5.bezier] newBezierObj() function expects an array, got ${typeof pointList}.`\n    )\n\n  // Check if all points are valid\n  if (_strict)\n    for (let point of pointList)\n      if (!Array.isArray(pointList) || point.length !== _dimension)\n        throw new Error(\n          '[p5.bezier] One or more points in the array are not input correctly.'\n        )\n\n  // All checks done\n  let bObj = new BezierCurve(pointList, closeType, tIncrement, _dimension)\n  return bObj\n}\n\nfunction _helper_factorial(a) {\n  // Factorial function for binomial coefficient calculation\n  return a > 1 ? a * _helper_factorial(a - 1) : 1\n}\n\nfunction _helper_dist() {\n  if (arguments.length === 4)\n    return Math.hypot(arguments[0] - arguments[2], arguments[1] - arguments[3])\n  else if (arguments.length === 6)\n    return Math.hypot(\n      arguments[0] - arguments[3],\n      arguments[1] - arguments[4],\n      arguments[2] - arguments[5]\n    )\n  return 0\n}\n\nfunction _helper_style() {\n  if (_canvas._doFill) _ctx.fill()\n  if (_canvas._doStroke) _ctx.stroke()\n}\n\nclass BezierCurve {\n  // Take pointList, closeType, tIncrement, bezierDimension into constructor\n  constructor(pL, closeT, tI, bD, vL = null) {\n    if (_strict && bD !== 2 && bD !== 3)\n      throw new Error(\n        `Dimension error. The bezier curve is ${bD}-dimensional and doesn't belong to our world.`\n      )\n\n    this.controlPoints = pL\n\n    if (closeT === 'CLOSE') {\n      this.controlPoints.push(pL[0])\n      this.closeType = 'CLOSE'\n    } else if (closeT === 'OPEN') {\n      this.closeType = 'OPEN'\n    } else {\n      throw new Error(\n        '[p5.bezier] Close type error. A bezier curve can only be either OPEN or CLOSE.'\n      )\n    }\n\n    this.dimension = bD\n    this.increment = tI\n    this.vertexList = []\n    this.vertexListLen = 0\n    this.p = this.controlPoints.length // Has p points for (p - 1) degree curves\n    this.n = this.p - 1 // Degree\n    // Calculate thr vertex\n    if (vL === null) {\n      this._buildVertexList()\n    } else {\n      this.vertexList = vL\n      this.vertexListLen = this.vertexList.length\n    }\n  }\n\n  _buildVertexList() {\n    /*\n    Return vertexList\n    */\n    this.vertexList = []\n    if (this.dimension === 2) {\n      // 2-Dimensional bezier curve\n      let x, y, t, i\n      for (t = 0; t <= 1; t += this.increment) {\n        x = 0\n        y = 0\n        for (i = 0; i <= this.n; i++) {\n          // i point in pointList\n          x +=\n            (_helper_factorial(this.n) /\n              (_helper_factorial(i) * _helper_factorial(this.n - i))) *\n            Math.pow(1 - t, this.n - i) *\n            Math.pow(t, i) *\n            this.controlPoints[i][0]\n          y +=\n            (_helper_factorial(this.n) /\n              (_helper_factorial(i) * _helper_factorial(this.n - i))) *\n            Math.pow(1 - t, this.n - i) *\n            Math.pow(t, i) *\n            this.controlPoints[i][1]\n        }\n        this.vertexList.push([x, y])\n      }\n    } else if (this.dimension === 3) {\n      // 3-Dimensional bezier curve\n      let xyz = [0, 0, 0],\n        t,\n        i,\n        d\n      for (t = 0; t <= 1; t += this.increment) {\n        xyz[0] = 0\n        xyz[1] = 0\n        xyz[2] = 0\n        for (i = 0; i <= this.n; i++) {\n          for (d = 0; d < 3; d++) {\n            xyz[d] +=\n              (_helper_factorial(this.n) /\n                (_helper_factorial(i) * _helper_factorial(this.n - i))) *\n              Math.pow(1 - t, this.n - i) *\n              Math.pow(t, i) *\n              this.controlPoints[i][d]\n          }\n        }\n        this.vertexList.push(xyz)\n      }\n    }\n    // Ending fix\n    this._addVertex(this.controlPoints.slice(-1)[0])\n\n    this.dimension = this.vertexList[0].length // Update dimension\n    this.vertexListLen = this.vertexList.length // Update vertexListLen\n    return this.vertexList\n  }\n\n  _addVertex(vArray) {\n    // vArray is an array of [x, y] position or [x, y, z] position\n    if (this.dimension === 2 || this.dimension === 3) _lineTo(...vArray)\n    else throw new Error('Vertices can only be in 2D or 3D space.')\n  }\n\n  _distVertex(vArray1, vArray2) {\n    // Calculate the distance between\n    // vertex_array_1 and vertex_array_2\n    if (this.dimension === 2) {\n      return _helper_dist(vArray1[0], vArray1[1], vArray2[0], vArray2[1])\n    } else if (this.dimension === 3) {\n      return _helper_dist(\n        vArray1[0],\n        vArray1[1],\n        vArray1[2],\n        vArray2[0],\n        vArray2[1],\n        vArray2[2]\n      )\n    }\n  }\n\n  draw(dash) {\n    if (!dash) {\n      _beginPath()\n      for (let v of this.vertexList) {\n        this._addVertex(v)\n      }\n\n      if (this.closeType === 'CLOSE') _ctx.closePath()\n\n      if (_useP5) _closePath(this.closeType)\n      else if (this.closeType === 'CLOSE') _closePath()\n\n      _helper_style()\n    } else if (\n      Array.isArray(dash) &&\n      dash.length === 2 &&\n      this.increment <= 0.008\n    ) {\n      // Draw a dash curve\n      let solidPart = Math.abs(dash[0]) // Length of one solid part\n      let onePart = solidPart + Math.abs(dash[1]),\n        nowLen = 0,\n        modOnePart = 0\n      let lastVertex = this.vertexList[0]\n      let solid = true // true draw, false break\n\n      _ctx.save() // push\n      _ctx.fillStyle = 'rgba(0, 0, 0, 0)' // TODO: Enable fill\n      _beginPath()\n      _moveTo(...this.vertexList[0])\n      for (let v = 1; v < this.vertexListLen; v++) {\n        nowLen += this._distVertex(lastVertex, this.vertexList[v])\n        modOnePart = nowLen % onePart\n        if (modOnePart <= solidPart && solid) {\n          this._addVertex(this.vertexList[v])\n        } else if (modOnePart > solidPart && modOnePart <= onePart && solid) {\n          // endShape()\n          solid = false\n        } else if (modOnePart <= solidPart && !solid) {\n          _moveTo(...this.vertexList[v])\n          solid = true\n        }\n        lastVertex = this.vertexList[v]\n      }\n      // if (solid) {\n      //   // Shape didn't end\n      //   endShape()\n      // }\n      _helper_style()\n      _ctx.restore()\n    } else if (this.increment > 0.008)\n      throw new Error(\n        'Fidelity is too low for a dash line. It should be at least 6.'\n      )\n    else\n      throw new Error(\n        \"Your dash array input is not valid. Make sure it's an array of two numbers.\"\n      )\n  }\n\n  update(newControlList) {\n    /*\n    Update the vertexList when control points change\n    */\n    if (newControlList.length !== this.controlPoints.length) {\n      throw new Error(\n        'The number of points changed. (Keep the length of the point array the same.)'\n      )\n    } else if (equalArrays(this.controlPoints, newControlList)) {\n      // Do we really need to update? No.\n      // return ;\n    } else {\n      this.controlPoints = newControlList\n      this._buildVertexList()\n    }\n  }\n\n  move(x, y, z = null, toDraw = true, dash = 0) {\n    /*\n    Move the curve to another place\n    Return a new object\n    */\n    if (z === null && this.dimension === 3) {\n      // A 3D curve treated as 2D error\n      throw new Error('To move a 3D curve, please specify (x, y, z).')\n    } else {\n      let toMove = [x, y]\n      if (z !== null) toMove.push(z)\n      // Copy to a new object\n      let newCurveV = []\n      for (let i = 0; i < this.vertexListLen; i++)\n        newCurveV.push(this.vertexList[i].slice())\n      let newCurveObj = new BezierCurve(\n        this.controlPoints,\n        this.closeType,\n        this.increment,\n        this.dimension,\n        newCurveV\n      )\n      // Move\n      for (let i = 0; i < newCurveObj.vertexListLen; i++) {\n        for (let j = 0; j < newCurveObj.dimension; j++) {\n          newCurveObj.vertexList[i][j] += toMove[j]\n        }\n      }\n      if (toDraw) {\n        newCurveObj.draw(dash)\n      }\n      return newCurveObj\n    }\n  }\n\n  shortest(pX, pY, pZ = 0) {\n    // Return the point on curve that is closest to the point outside\n    // Always return array length of 3\n    // Last position (z) be 0 for all 2D calculation\n    let dMin = -1,\n      nowMin = 0\n    let minVertex\n    for (let v of this.vertexList) {\n      if (dMin === -1) {\n        dMin = this._distVertex(v, [pX, pY, pZ])\n        minVertex = v\n      } else {\n        nowMin = this._distVertex(v, [pX, pY, pZ])\n        if (dMin > nowMin) {\n          dMin = nowMin\n          minVertex = v\n        }\n      }\n    }\n    return minVertex // An array of vertex position\n  }\n}\n\n/* --------------------------------- HELPERS -------------------------------- */\n\n// https://www.30secondsofcode.org/blog/s/javascript-array-comparison\nconst equalArrays = (a, b) =>\n  a.length === b.length && a.every((v, i) => v === b[i])\n"],"names":[],"sourceRoot":""}