(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["initBezier"] = factory();
	else
		root["initBezier"] = factory();
})(this, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/coefficients.ts":
/*!*****************************!*\
  !*** ./src/coefficients.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MAX_DEGREE: () => (/* binding */ MAX_DEGREE),
/* harmony export */   _accuracies: () => (/* binding */ _accuracies),
/* harmony export */   _binomialCoefficient: () => (/* binding */ _binomialCoefficient)
/* harmony export */ });
var MAX_DEGREE = 160;
var _accuracies = {
    1: 0.1,
    2: 0.02,
    3: 0.001,
    4: 0.0005,
    5: 0.0001,
};
var _calculatedFactorials = [1];
var _binomialCoefficients = {};
/* -------------------------------------------------------------------------- */
function _helper_ensureFactorials(n) {
    var prevLen = _calculatedFactorials.length;
    for (var i = prevLen; i <= n; i++)
        _calculatedFactorials[i] = i * _calculatedFactorials[i - 1];
}
function _f(i) {
    return _calculatedFactorials[i];
}
/* -------------------------------------------------------------------------- */
function _helper_ensureBinomialCoefficients(_n) {
    for (var n = 2; n <= _n; n++) {
        _binomialCoefficients[n] = {};
        for (var i = 1; i < n; i++) {
            _binomialCoefficients[n][i] = _f(n) / (_f(i) * _f(n - i));
        }
    }
}
function _binomialCoefficient(n, i) {
    if (i === 0 || i === n)
        return 1;
    return _binomialCoefficients[n][i];
}
/* -------------------------------------------------------------------------- */
_helper_ensureFactorials(MAX_DEGREE + 1);
_helper_ensureBinomialCoefficients(MAX_DEGREE + 1);


/***/ }),

/***/ "./src/utils.ts":
/*!**********************!*\
  !*** ./src/utils.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   _concentrate: () => (/* binding */ _concentrate),
/* harmony export */   _dist: () => (/* binding */ _dist),
/* harmony export */   _getCanvasUtils: () => (/* binding */ _getCanvasUtils),
/* harmony export */   _getCloseCurvePoints: () => (/* binding */ _getCloseCurvePoints),
/* harmony export */   _getDimension: () => (/* binding */ _getDimension),
/* harmony export */   _interpolateVertex: () => (/* binding */ _interpolateVertex),
/* harmony export */   _setStyles: () => (/* binding */ _setStyles)
/* harmony export */ });
/* harmony import */ var _coefficients__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./coefficients */ "./src/coefficients.ts");
var __spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};

function _getDimension(
// biome-ignore lint/suspicious/noExplicitAny: p5 typing
context, isP3D) {
    return context.constructor.name === 'WebGLRenderingContext' || isP3D ? 3 : 2;
}
function _getCanvasUtils(b) {
    if (b.useP5) {
        b.beginPath = b.canvas.beginShape;
        b.moveTo = b.canvas.vertex;
        b.lineTo = b.canvas.vertex;
        b.closePath = b.canvas.endShape;
    }
    else {
        if (b.ctx instanceof WebGLRenderingContext) {
            b.beginPath = function () { };
            b.moveTo = function (x, y, z) {
                if (z === void 0) { z = 0; }
                return b.ctx.vertexAttrib3f(0, x, y, z);
            };
            b.lineTo = function (x, y, z) {
                if (z === void 0) { z = 0; }
                return b.ctx.vertexAttrib3f(0, x, y, z);
            };
            b.closePath = function () { };
        }
        else {
            b.beginPath = b.ctx.beginPath.bind(b.ctx);
            b.moveTo = b.ctx.moveTo.bind(b.ctx);
            b.lineTo = b.ctx.lineTo.bind(b.ctx);
            b.closePath = b.ctx.closePath.bind(b.ctx);
        }
    }
}
function _dist() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var len = args.length;
    if (len === 4) {
        var dx = args[0] - args[2];
        var dy = args[1] - args[3];
        return Math.sqrt(dx * dx + dy * dy);
    }
    if (len === 6) {
        var dx = args[0] - args[3];
        var dy = args[1] - args[4];
        var dz = args[2] - args[5];
        return Math.sqrt(dx * dx + dy * dy + dz * dz);
    }
    return 0;
}
function _setStyles(b) {
    if (b.canvas._doFill)
        b.ctx.fill();
    if (b.canvas._doStroke)
        b.ctx.stroke();
}
/* -------------------------------------------------------------------------- */
var SeedRandom = /** @class */ (function () {
    function SeedRandom(seed) {
        this.m = Math.pow(2, 31) - 1;
        this.a = 1103515245;
        this.c = 12345;
        this.state = seed;
    }
    SeedRandom.prototype.r = function () {
        this.state = (this.a * this.state + this.c) % this.m;
        return this.state / this.m;
    };
    SeedRandom.prototype.next = function (min, max) {
        return Math.floor(this.r() * (max - min + 1)) + min;
    };
    return SeedRandom;
}());
var seed = 1234;
function _concentrate(pointList, close) {
    if (close === void 0) { close = false; }
    var save = close ? 3 : 0;
    var limit = _coefficients__WEBPACK_IMPORTED_MODULE_0__.MAX_DEGREE - save;
    if (pointList.length <= limit)
        return _copy(pointList);
    var excessPoints = pointList.length - limit;
    var rng = new SeedRandom(seed);
    var rmIndex = new Set();
    __spreadArray([], new Array(excessPoints), true).map(function (_, ind) {
        var r = rng.next(5 + ind, limit - 5 + ind);
        while (rmIndex.has(r)) {
            r = rng.next(5 + ind, limit - 5 + ind);
        }
        rmIndex.add(r);
    });
    return _copy(pointList.filter(function (_, index) { return !rmIndex.has(index); }));
}
function _copy(arr) {
    return arr.map(function (v) { return v.slice(); });
}
function _getCloseCurvePoints(pointList) {
    var len = pointList.length;
    if (len === 0)
        return [];
    var first = pointList[0];
    var last = pointList[len - 1];
    if (len === 1)
        return _copy([first]);
    var second = pointList[1];
    var secondLast = pointList[len - 2];
    return _copy([
        [2 * last[0] - secondLast[0], 2 * last[1] - secondLast[1]],
        [2 * first[0] - second[0], 2 * first[1] - second[1]],
        first,
    ]);
}
function _interpolateVertex(v1, v2, t) {
    var len1 = v1.length;
    var len2 = v2.length;
    if (len1 === 2 && len2 === 2) {
        return [v1[0] + (v2[0] - v1[0]) * t, v1[1] + (v2[1] - v1[1]) * t];
    }
    if (len1 === 3 && len2 === 3) {
        return [
            v1[0] + (v2[0] - v1[0]) * t,
            v1[1] + (v2[1] - v1[1]) * t,
            v1[2] + (v2[2] - v1[2]) * t,
        ];
    }
    return v2;
}


/***/ }),

/***/ "./package.json":
/*!**********************!*\
  !*** ./package.json ***!
  \**********************/
/***/ ((module) => {

module.exports = /*#__PURE__*/JSON.parse('{"name":"p5bezier","version":"0.6.0","author":"Peiling Jiang","repository":{"type":"git","url":"https://github.com/peilingjiang/p5.bezier.git"},"main":"lib/p5.bezier.min.js","devDependencies":{"@biomejs/biome":"^1.8.3","@types/p5":"^1.7.6","husky":"^9.1.5","lint-staged":"^15.2.9","prettier":"^3.3.3","terser-webpack-plugin":"^5.3.10","ts-loader":"^9.5.1","typescript":"^5.5.4","webpack":"^5.93.0","webpack-cli":"^5.1.4"},"bugs":{"url":"https://github.com/peilingjiang/p5.bezier/issues"},"description":"Bezier curves for canvas graphics on the web, built to work with p5.js","files":["lib"],"homepage":"https://github.com/peilingjiang/p5.bezier#readme","keywords":["p5.js","Bezier","Computer Graphics"],"license":"MIT","lint-staged":{"*.{ts,json}":"biome check --write --no-errors-on-unmatched","*.{css,md,html}":"prettier --write"},"scripts":{"format":"biome format --write . && prettier --write \\"**/*.{css,md,html}\\"","lint":"biome check --write .","start":"webpack --env=development","build":"webpack --env=production","prepare":"husky"},"types":"lib/p5.bezier.d.ts"}');

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
/*!**************************!*\
  !*** ./src/p5.bezier.ts ***!
  \**************************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _package_json__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../package.json */ "./package.json");
/* harmony import */ var _coefficients__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./coefficients */ "./src/coefficients.ts");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ "./src/utils.ts");
/*
p5.bezier library by Peiling Jiang
2020

updated Aug 2024
*/
var __spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};



window.console.log("[p5.bezier] ".concat(_package_json__WEBPACK_IMPORTED_MODULE_0__.version));
/* -------------------------------------------------------------------------- */
/* -------------------------------------------------------------------------- */
/* -------------------------------------------------------------------------- */
// helpers
function _bezierVertex(pointList, n, t, dimension) {
    var vertex = new Array(dimension).fill(0);
    var oneMinusT = 1 - t;
    for (var i = 0; i <= n; i++) {
        var coefficient = (0,_coefficients__WEBPACK_IMPORTED_MODULE_1__._binomialCoefficient)(n, i) * Math.pow(oneMinusT, (n - i)) * Math.pow(t, i);
        for (var d = 0; d < dimension; d++)
            vertex[d] += coefficient * pointList[i][d];
    }
    return vertex;
}
function _drawBezierCurve(bezierCanvas, pointList, accuracy) {
    var n = pointList.length - 1;
    var increment = _coefficients__WEBPACK_IMPORTED_MODULE_1__._accuracies[accuracy];
    for (var t = 0; t <= 1; t += increment) {
        var v = _bezierVertex(pointList, n, t, bezierCanvas.dimension);
        bezierCanvas.lineTo.apply(bezierCanvas, v);
    }
}
/* -------------------------------------------------------------------------- */
/* -------------------------------------------------------------------------- */
/* -------------------------------------------------------------------------- */
var P5Bezier = /** @class */ (function () {
    // biome-ignore lint/suspicious/noExplicitAny: p5 typing
    function P5Bezier(canvas) {
        this.b = {
            canvas: null,
            ctx: null,
            dimension: 2,
            useP5: true,
            beginPath: function () { },
            moveTo: function () { },
            lineTo: function () { },
            closePath: function () { },
        };
        this.b.canvas = canvas;
        this.b.ctx = this.b.canvas.drawingContext;
        if (typeof p5 !== 'undefined' && canvas instanceof p5.Graphics) {
            this.b.useP5 = true;
            this.b.dimension = (0,_utils__WEBPACK_IMPORTED_MODULE_2__._getDimension)(this.b.ctx, false);
        }
        else if ((typeof p5 !== 'undefined' && canvas instanceof p5.Renderer) ||
            canvas.drawingContext) {
            this.b.useP5 = false;
            if (typeof p5 === 'undefined' ||
                (typeof p5 !== 'undefined' && !(canvas instanceof p5.Renderer)))
                window.console.warn('[p5.bezier] Support beyond p5.js is not tested');
            this.b.dimension = (0,_utils__WEBPACK_IMPORTED_MODULE_2__._getDimension)(this.b.ctx, canvas.isP3D);
        }
        else
            throw new Error('[p5.bezier] Canvas is not supported');
        (0,_utils__WEBPACK_IMPORTED_MODULE_2__._getCanvasUtils)(this.b);
    }
    P5Bezier.prototype.draw = function (pointList, closeType, accuracy) {
        var _a, _b;
        if (closeType === void 0) { closeType = 'OPEN'; }
        if (accuracy === void 0) { accuracy = 3; }
        var _pL = closeType === 'CLOSE'
            ? __spreadArray(__spreadArray([], (0,_utils__WEBPACK_IMPORTED_MODULE_2__._concentrate)(pointList, true), true), (0,_utils__WEBPACK_IMPORTED_MODULE_2__._getCloseCurvePoints)(pointList), true) : (0,_utils__WEBPACK_IMPORTED_MODULE_2__._concentrate)(pointList);
        this.b.beginPath();
        (_a = this.b).moveTo.apply(_a, _pL[0]);
        _drawBezierCurve(this.b, _pL, accuracy);
        (_b = this.b).lineTo.apply(_b, _pL[_pL.length - 1]);
        if (this.b.useP5)
            this.b.closePath(closeType);
        else if (closeType === 'CLOSE')
            this.b.closePath();
        (0,_utils__WEBPACK_IMPORTED_MODULE_2__._setStyles)(this.b);
        return _pL;
    };
    P5Bezier.prototype.new = function (pointList, closeType, accuracy) {
        if (closeType === void 0) { closeType = 'OPEN'; }
        if (accuracy === void 0) { accuracy = 3; }
        var increment = _coefficients__WEBPACK_IMPORTED_MODULE_1__._accuracies[accuracy];
        return new BezierCurve(pointList, closeType, increment, this.b);
    };
    return P5Bezier;
}());
// biome-ignore lint/suspicious/noExplicitAny: p5 typing
function initBezier(canvas) {
    return new P5Bezier(canvas);
}
/* -------------------------------------------------------------------------- */
var BezierCurve = /** @class */ (function () {
    function BezierCurve(points, closeType, increment, bezierCanvas, vertexList) {
        var _a;
        if (vertexList === void 0) { vertexList = null; }
        this.controlPoints = (0,_utils__WEBPACK_IMPORTED_MODULE_2__._concentrate)(points, closeType === 'CLOSE');
        if (closeType === 'CLOSE') {
            (_a = this.controlPoints).push.apply(_a, (0,_utils__WEBPACK_IMPORTED_MODULE_2__._getCloseCurvePoints)(this.controlPoints));
            this.closeType = 'CLOSE';
        }
        else
            this.closeType = 'OPEN';
        this.dimension = bezierCanvas.dimension;
        this.increment = increment;
        this.vertexList = [];
        this.p = this.controlPoints.length; // has p points for (p - 1) degree curves
        this.n = this.p - 1; // degree
        this.b = bezierCanvas;
        if (vertexList === null)
            this._buildVertexList();
        else
            this.vertexList = __spreadArray([], vertexList, true);
    }
    BezierCurve.prototype._buildVertexList = function () {
        this.vertexList = [];
        for (var t = 0; t <= 1; t += this.increment) {
            var v = _bezierVertex(this.controlPoints, this.n, t, this.dimension);
            this.vertexList.push(v);
        }
        this._addVertex(this.controlPoints[this.controlPoints.length - 1]);
        this.dimension = this.vertexList[0].length;
        return this.vertexList;
    };
    BezierCurve.prototype._addVertex = function (vArray) {
        var _a;
        (_a = this.b).lineTo.apply(_a, vArray);
    };
    BezierCurve.prototype._distVertex = function (vArray1, vArray2) {
        return this.dimension === 3 && vArray1.length === 3 && vArray2.length === 3
            ? (0,_utils__WEBPACK_IMPORTED_MODULE_2__._dist)(vArray1[0], vArray1[1], vArray1[2], vArray2[0], vArray2[1], vArray2[2])
            : this.dimension === 2
                ? (0,_utils__WEBPACK_IMPORTED_MODULE_2__._dist)(vArray1[0], vArray1[1], vArray2[0], vArray2[1])
                : 0;
    };
    BezierCurve.prototype.draw = function (dash) {
        if (!dash) {
            this._solidCurve();
        }
        else {
            this._dashedCurve(dash);
        }
    };
    BezierCurve.prototype._solidCurve = function () {
        var _this = this;
        this.b.beginPath();
        this.vertexList.map(function (v) { return _this._addVertex(v); });
        if (this.closeType === 'CLOSE')
            this.b.closePath();
        if (this.b.useP5)
            this.b.closePath(this.closeType);
        else if (this.closeType === 'CLOSE')
            this.b.closePath();
        (0,_utils__WEBPACK_IMPORTED_MODULE_2__._setStyles)(this.b);
    };
    BezierCurve.prototype._dashedCurve = function (dash) {
        var _a, _b, _c, _d, _e;
        if (this.increment > 0.008) {
            this.increment = 0.008;
            window.console.warn('[p5.bezier] Accuracy is changed to 6 for a dash curve');
        }
        var _f = dash.map(Math.abs), solidPart = _f[0], gapPart = _f[1];
        var solid = true;
        var lastVertex = this.vertexList[0];
        var toUseVertexInd = 1;
        var currentVirtualVertex = lastVertex;
        var availableDist = 0;
        var neededDist = solidPart;
        this.b.ctx.save();
        this.b.ctx.fillStyle = 'rgba(0, 0, 0, 0)';
        this.b.beginPath();
        (_a = this.b).moveTo.apply(_a, lastVertex);
        while (toUseVertexInd < this.vertexList.length) {
            var toUseVertex = this.vertexList[toUseVertexInd];
            availableDist = this._distVertex(lastVertex, toUseVertex);
            while (availableDist >= neededDist) {
                currentVirtualVertex = (0,_utils__WEBPACK_IMPORTED_MODULE_2__._interpolateVertex)(currentVirtualVertex, toUseVertex, neededDist / availableDist);
                solid
                    ? (_b = this.b).lineTo.apply(_b, currentVirtualVertex) : (_c = this.b).moveTo.apply(_c, currentVirtualVertex);
                availableDist -= neededDist;
                solid = !solid;
                neededDist = solid ? solidPart : gapPart;
            }
            solid ? (_d = this.b).lineTo.apply(_d, toUseVertex) : (_e = this.b).moveTo.apply(_e, toUseVertex);
            neededDist -= this._distVertex(currentVirtualVertex, toUseVertex);
            lastVertex = toUseVertex;
            currentVirtualVertex = lastVertex;
            toUseVertexInd++;
        }
        (0,_utils__WEBPACK_IMPORTED_MODULE_2__._setStyles)(this.b);
        this.b.ctx.restore();
    };
    BezierCurve.prototype.update = function (newControlPointList) {
        if (newControlPointList.length !== this.controlPoints.length) {
            throw new Error('[p5.bezier] The number of control points changed');
        }
        if (this.controlPoints.every(function (v, i) { return v === newControlPointList[i]; })) {
            return;
        }
        this.controlPoints = newControlPointList;
        this._buildVertexList();
    };
    BezierCurve.prototype.move = function (x, y, z, toDraw, dash) {
        if (z === void 0) { z = null; }
        if (toDraw === void 0) { toDraw = true; }
        if (z === null && this.dimension === 3) {
            throw new Error('[p5.bezier] X, Y, and Z are needed to move a 3D curve');
        }
        var toMove = [x, y];
        if (z !== null)
            toMove.push(z);
        var newCurveV = this.vertexList.map(function (v) { return v.slice(); });
        var newCurveObj = new BezierCurve(this.controlPoints, this.closeType, this.increment, this.b, newCurveV);
        newCurveObj.vertexList = newCurveObj.vertexList.map(function (v) { return v.map(function (val, i) { return val + toMove[i]; }); });
        if (toDraw)
            newCurveObj.draw(dash);
        return newCurveObj;
    };
    BezierCurve.prototype.shortest = function (pX, pY, pZ) {
        var _this = this;
        if (pZ === void 0) { pZ = 0; }
        var minVertex = [0, 0, 0];
        var dMin = Number.POSITIVE_INFINITY;
        this.vertexList.map(function (v) {
            var nowMin = _this._distVertex(v, [pX, pY, pZ]);
            if (dMin > nowMin) {
                dMin = nowMin;
                minVertex = __spreadArray([], v, true);
            }
        });
        return minVertex;
    };
    return BezierCurve;
}());
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (initBezier);

__webpack_exports__ = __webpack_exports__["default"];
/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=p5.bezier.min.js.map